%test

  function f$$ () {
    print regress expansion of function names
  }
  f$$
0:Regression test: `function f$$ () { ... }'
>regress expansion of function names

  function foo () print bar
  foo
0:Function definition without braces
>bar

  functions -M m1
  m1() { (( $# )) }
  print $(( m1() ))
  print $(( m1(1) ))
  print $(( m1(1,2) ))
0:User-defined math functions, argument handling
>0
>1
>2

  functions -M m2
  m2() {
    integer sum
    local val
    for val in $*; do
      (( sum += $val ))
    done
  }
  print $(( m2(1) ))
  print $(( m2(1,3+3,4**2) ))
0:User-defined math functions, complex argument handling
>1
>23

  functions -M m3 1 2
  m3() { (( 1 )) }
  print zero
  (print $(( m3() )))
  print one
  print $(( m3(1) ))
  print two
  print $(( m3(1,2) ))
  print three
  (print $(( m3(1,2,3) )))
1:User-defined math functions, argument checking
>zero
>one
>1
>two
>1
>three
?(eval):4: wrong number of arguments: m3()
?(eval):10: wrong number of arguments: m3(1,2,3)

  functions -M m4 0 0 testmathfunc
  functions -M m5 0 0 testmathfunc
  testmathfunc() {
    if [[ $0 = m4 ]]; then
      (( 4 ))
    else
      (( 5 ))
    fi
  }
  print $(( m4() ))
  print $(( m5() ))
0:User-defined math functions, multiple interfaces
>4
>5

  command_not_found_handler() {
    print "Great News!  I've handled the command:"
    print "$1"
    print "with arguments:"
    print -l ${argv[2,-1]}
  }
  ACommandWhichHadBetterNotExistOnTheSystem and some "really useful" args
0:Command not found handler, success
>Great News!  I've handled the command:
>ACommandWhichHadBetterNotExistOnTheSystem
>with arguments:
>and
>some
>really useful
>args

  command_not_found_handler() {
     print "Your command:" >&2
     print "$1" >&2
     print "has gone down the tubes.  Sorry." >&2
     return 1
  }
  ThisCommandDoesNotExistEither
127:Command not found handler, failure
?Your command:
?ThisCommandDoesNotExistEither
?has gone down the tubes.  Sorry.
?(eval):7: command not found: ThisCommandDoesNotExistEither

  local variable=outside
  print "I am $variable"
  function {
    local variable=inside
    print "I am $variable"
  }
  print "I am $variable"
  () {
    local variable="inside again"
    print "I am $variable"
  }
  print "I am $variable"
0:Anonymous function scope
>I am outside
>I am inside
>I am outside
>I am inside again
>I am outside

  integer i
  for (( i = 0; i < 10; i++ )); do function {
    case $i in
    ([13579])
    print $i is odd
    ;|
    ([2468])
    print $i is even
    ;|
    ([2357])
    print $i is prime
    ;;
    esac
  }; done
0:Anonymous function with patterns in loop
>1 is odd
>2 is even
>2 is prime
>3 is odd
>3 is prime
>4 is even
>5 is odd
>5 is prime
>6 is even
>7 is odd
>7 is prime
>8 is even
>9 is odd

  echo stuff in file >file.in
  function {
    sed 's/stuff/rubbish/'
  } <file.in >file.out
  cat file.out
0:Anonymous function redirection
>rubbish in file

  variable="Do be do"
  print $variable
  function {
     print $variable
     local variable="Da de da"
     print $variable
     function {
       print $variable
       local variable="Dum da dum"
       print $variable
     }
     print $variable
  }
  print $variable
0:Nested anonymous functions
>Do be do
>Do be do
>Da de da
>Da de da
>Dum da dum
>Da de da
>Do be do
