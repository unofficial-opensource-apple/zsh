# Tests for the echo, print, printf and pushln builtins

# Tested elsewhere:
#  Use of print -p to output to coprocess	A01grammar
#  Prompt expansion with print -P		D01prompt
#  -l, -r, -R and -n indirectly tested in various places

# Not yet tested:
#  echo and pushln
#  print's -b -c -s -z -N options


%test

 print -D "${HOME:-~}"
0:replace directory name
>~

 print -u2 'error message'
0:output to file-descriptor
?error message

 print -o foo bar Baz
0:argument sorting
>Baz bar foo

 print -f
1:print -f needs a format specified
?(eval):print:1: argument expected: -f

 print -Of '%s\n' foo bar baz
0:reverse argument sorting
>foo
>baz
>bar

 print -io a B c
0:case-insensitive argument sorting
>a B c

 print -m '[0-9]' one 2 three 4 five 6
0:removal of non-matching arguments
>2 4 6

 printf '%s\n' string
0:test s format specifier
>string

 printf '%b' '\t\\\n'
0:test b format specifier
>	\

 printf '%q\n' '=a=b \ c!'
0: test q format specifier
>\=a=b\ \\\ c!

 printf '%c\n' char
0:test c format specifier
>c

 printf '%.10e%n\n' 1 count >/dev/null
 printf '%d\n' $count
0:test n format specifier
>16

 printf '%d\n' 123
0:test d format specifier
>123

 printf '%g\n' 123.45
0:test g format specifier
>123.45

# Is anyone not using ASCII
 printf '%d\n' \'A
0:initial quote to get numeric value of character with int
>65

 printf '%.1E\n' \'B
0:initial quote to get numeric value of character with double
>6.6E+01

 printf '%x\n' $(printf '"\xf0')
0:numeric value of high numbered character
>f0

# code will probably be changed to print the literal `%s' in this case
 printf '\x25s\n' arg
0:using \x25 to introduce a format specifier
>arg

 printf '%3c\n' c
0:width specified in format specifier
>  c

 printf '%.4s\n' chopped
0:precision specified in format specifier
>chop

 printf '%*.*f\n' 6 2 10.2
0:width/precision specified in arguments
> 10.20

 printf '%z'
1:use of invalid directive
?(eval):printf:1: %z: invalid directive

 printf '%d\n' 3a
1:bad arithmetic expression
?(eval):1: bad math expression: operator expected at `a'
>0

 printf '%12$s' 1 2 3
1:out of range argument specifier
?(eval):printf:1: 12: argument specifier out of range

 printf '%2$s\n' 1 2 3
1:out of range argument specifier on format reuse
?(eval):printf:1: 2: argument specifier out of range
>2

 printf '%*0$d'
1:out of range argument specifier on width
?(eval):printf:1: 0: argument specifier out of range

 print -m -f 'format - %s.\n' 'z' a b c
0:format not printed if no arguments left after -m removal

 print -f 'format - %s.\n'
0:format printed despite lack of arguments
>format - .

 printf 'x%4sx\n'
0:with no arguments empty string where string needed
>x    x

 printf '%d\n'
0:with no arguments, zero used where number needed
>0

 printf '%s\t%c:%#x%%\n' one a 1 two b 2 three c 3
0:multiple arguments with format reused
>one	a:0x1%
>two	b:0x2%
>three	c:0x3%

 printf '%d%n' 123 val val val > /dev/null
 printf '%d\n' val
0:%n count zeroed on format reuse
>1

# this should fill spec string with '%0+- #*.*d\0' - 11 characters
 printf '%1$0+- #-08.5dx\n' 123
0:maximal length format specification
>+00123  x

 printf '%*smorning\n' -5 good
0:negative width specified
>good morning

 printf '%.*g\n' -1 .1
0:negative precision specified
>0.1

 printf '%2$s %1$d\n' 1 2
0:specify argument to output explicitly
>2 1

 printf '%3$.*1$d\n' 4 0 3
0:specify output and precision arguments explicitly
>0003

 printf '%2$d%1$d\n' 1 2 3 4
0:reuse format where arguments are explicitly specified
>21
>43

 printf '%1$*2$d' 1 2 3 4 5 6 7 8 9 10;echo
0:reuse of specified arguments 
> 1   3     5       7         9

 printf '%1$0+.3d\n' 3
0:flags mixed with specified argument
>+003

# The following usage, as stated in the manual, is not recommended and the
# results are undefined. Tests are here anyway to ensure some form of
# half-sane behaviour.

 printf '%2$s %s %3$s\n' Morning Good World
0:mixed style of argument selection
>Good Morning World

 printf '%*1$.*d\n' 1 2
0:argument specified for width only
>00

 print -f '%*.*1$d\n' 1 2 3
0:argument specified for precision only
>2
>000

 printf -- '%s\n' str
0:initial `--' ignored to satisfy POSIX
>str
